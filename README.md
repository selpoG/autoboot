# autoboot

Automatical Generator of Conformal Bootstrap Equation

For more information, see
[autoboot: A generator of bootstrap equations with global symmetry](https://arxiv.org/abs/1903.10522).

Some usages also can be checked by typing `?someSymbolName` (for example, `?getGroup`) in [Mathematica](http://reference.wolfram.com/language/tutorial/GettingInformationAboutWolframLanguageObjects.html).
``?somePackageName`*`` (for example, ``?ClebschGordan`*``) will give package-lebel information.

## Setup

```sh
tar xvf sgd.tar.xz
```

## Usage

To use autoboot, you have to load either `group.m` or `ngroup.m` (**not both**).
`ngroup.m` requires **just one call** of `setPrecision`, which controls the precision of calculation in autoboot.

If you load `group.m`, all numerical values are rigorous and it takes much time in calculation (in some cases, Mathematica will freeze).

If you load `ngroup.m`, all numerical values (except for signs, multiplicities and so on) are approximated and it takes much less time.

### Groups

autoboot supports many **finite groups**, some **Lie groups** and **product groups** of them.
More formally, groups which we can treat as a global symmetry of CFT are defined by:

```EBNF
$group = $finite_group | $lie_group | pGroup[$group,$group]
$finite_group = group[$n,$n] | dih[$n] | dic[$n]
$lie_group = su[2] | so[2] | so[3] | o[2] | o[3]
$n = positive_integer
```

Once you get a group `G`:

1. Set `G` as a global symmetry by `setGroup[G]` (if you call this more than once, all values calculated by autoboot previously will be cleared).

1. Register fundamental operators by `setOps[...]`. 'Fundamental' means that the operator in summation of all primary operator will be treated independently.

1. Get bootstrap equations by `bootAll[]`. If you need human-readable format, use `format[...]`.

1. *(Optionally)* You can get a Python code for [cboot](https://github.com/tohtsky/cboot) by `toString[makeSDP[eq]]`.

### Irreps

All labels of irreps are defined as follows:

1. For `G=group[g,i]`, all irreps are labeled by `rep[n]` (`n=1,2,...,g[ncg]`).
   `rep[n]` corresponds to n-th irrep in `Irr(SmallGroup(g,i))` in GAP.
   The character table can be accessed by `G[ct]` and n-th row is the character of `rep[n]`.
   `G[id]` is `rep[1]`.

1. For `G=so[2]`, all irreps are labeled by `v[x]` (`x` is a real number).
   Let `G` is generated by `s`.
   `v[x]` is the 1-dimensional representation in which `s` is represented by `{{x}}`.
   `G[id]` is `v[0]` and the standard vector representation is `v[1]`.

1. For `G=o[2]`, all irreps are labeled by `i[1]`, `i[-1]` or `v[n]` (`n=1,2,...`).
   Let `G` is generated by `s={{0,-1}, {1,0}` and `t={{1,0}, {0,-1}}`.
   `i[\pm 1]` is the 1-dimensional representation in which `t` is represented by `{{\pm 1}}`.
   `v[n]` is the 2-dimensional representation in which `s` is represented by `{{0,-n}, {n,0}}`.
   `G[id]` is `i[1]` and the standard vector representation is `v[1]`.

1. For `G=so[3]`, all irreps are labeled by `v[n]` (`n=0,1,2,...`).
   `v[n]` is the spin-n representation, which dimension is `2*n+1`.
   `G[id]` is `v[0]` and the standard vector representation is `v[1]`.

1. For `G=o[3]`, all irreps are labeled by `v[n,\pm 1]` (`n=0,1,2,...`).
   `v[n,\pm 1]` is the spin-n representation which represents the inversion `diag(-1,-1,-1)` by `\pm 1`.
   `G[id]` is `v[0,1]` and the standard vector representation is `v[1,-1]`.

1. For `G=su[2]`, all irreps are labeled by `v[n]` (`n=0,1/2,1,3/2,...`).
   `v[n]` is the spin-n representation, which dimension is `2*n+1`.
   `G[id]` is `v[0]` and the standard vector representation is `v[1]`.

1. For `G=dih[N]` (`N`: even), all irreps are labeled by `i[\pm 1,\pm 1]` and `v[n]` (`n=1,2,...,N/2-1`).
   Let `G` is generated by `s={{q,0}, {0,1/q}}` (`q=exp(2Pi/N)`) and `t` (reflection by `y=x`).
   `i[p,q]` (`p,q=\pm 1`) represents `s` by `{{q}}` and `t` by `{{p}}`.
   `v[n]` represents `s` by `s^n` and `t` as-is.
   `G[id]` is `i[1,1]` and the standard vector representation is `v[1]`.

1. For `G=dih[N]` (`N`: odd), all irreps are labeled by `i[\pm 1]` and `v[n]` (`n=1,2,...,(N-1)/2`).
   Let `G` is generated by `s={{q,0}, {0,1/q}}` (`q=exp(2Pi/N)`) and `t` (reflection by `y=x`).
   `i[\pm 1]` represents `s` by `{{1}}` and `t` by `{{\pm 1}}`.
   `v[n]` represents `s` by `s^n` and `t` as-is.
   `G[id]` is `i[1]` and the standard vector representation is `v[1]`.

1. For `G=dic[N]`, all irreps are labeled by `i[\pm 1,\pm 1]` and `v[n]` (`n=1,2,...,N-1`).
   Let `G` is generated by `s={{q,0}, {0,1/q}}` (`q=exp(Pi/N)`) and `t` (`Pi/2` rotation).
   `i[p,q]` (`p,q=\pm 1`) represents `s` by `{{p}}` and `t` by `{{q}}` or `{{q I}}`.
   `v[n]` represents `s` by `s^n` and `t` by `{{0,(-1)^n},{1,0}}`.
   `G[id]` is `i[1,1]` and the standard vector representation is `v[1]`.

1. For `G=pGroup[G1,G2]`, all irreps are labeled by `rep[r1,r2]`
   (`r1` is a irrep of `G1` and `r2` is a irrep of `G2`).
   `G[id]` is `rep[G1[id],G2[id]]`.

## Example

This example generates a bootstrap equation of D8-symmetric CFT.
More example codes can be found in [`sample` folder](https://github.com/selpoG/autoboot/tree/master/sample).

```Mathematica
(* change the path of autoboot properly *)
SetDirectory["~/autoboot/"];
<< "group.m"
(* getGroup[8, 3] is isomorphic to getDihedral[4] *)
d8 = getGroup[8, 3];
setGroup[d8];
(* set e and v as fundamental operators. rep[5] is the unique 2-dim irrep of d8 (you can check this by d8[ct]). *)
setOps[{op[e, d8[id], 1, 1], op[v, rep[5], 1, 1]}]
format[eq = bootAll[]]
ans = makeSDP[eq];
WriteString["d8.py", toCboot[ans]]
(* specify how to convert operators to latex code *)
opToTeX[e] := "\\epsilon"
opToTeX[v] := "v"
(* specify how to convert irreps to latex code *)
repToTeX[rep[n_]] := TemplateApply["\\mathbf{`n`}", <|"n" -> n|>]
(* you can paste printed string to your latex file *)
Print[toTeX[eq]]
```
